#!/bin/bash
# /tmp/k8s_scripts/00-shared-functions.sh
# Shared functions for all K8s setup scripts

# Global settings that all scripts should use
export DEBIAN_FRONTEND=noninteractive

# Global variables
SYSTEM_PREPARED=false

# =================================================================
# ENHANCED LOGGING SETUP WITH VERBOSITY CONTROL
# =================================================================

setup_logging() {
    # Configuration from environment or defaults
    local LOG_DIR=${log_dir}
    local LOG_LEVEL=${log_level}
    local LOG_LEVEL="$${LOG_LEVEL:-INFO}"
    local DEBUG_MODE="$${DEBUG:-0}"
    
    # Create log directory
    mkdir -p "$${LOG_DIR}"
    chown "$(whoami):$(whoami)" "$${LOG_DIR}" 2>/dev/null || true
    
    # Auto-detect calling script name or use parameter
    local script_name
    if [[ -n "$${1:-}" ]]; then
        script_name="$1"
    else
        script_name="$(basename "$${BASH_SOURCE[1]}" .sh)"
    fi
    
    # Setup log file paths
    full_log_path="$${LOG_DIR}/$${script_name}.log"
    error_log_path="$${LOG_DIR}/$${script_name}-error.log"
    debug_log_path="$${LOG_DIR}/$${script_name}-debug.log"
    trace_log_path="$${LOG_DIR}/$${script_name}-trace.log"
    
    # Configure bash behavior and logging based on log level
    case "$${LOG_LEVEL}" in
        ERROR)
            # Only errors, no info output
            set -euo pipefail
            exec 1>/dev/null
            exec 2> >(tee -a "$${error_log_path}")
            ;;
        WARN)
            # Warnings and errors only
            set -euo pipefail
            exec 1> >(tee -a "$${full_log_path}")
            exec 2> >(tee -a "$${error_log_path}" >&2)
            ;;
        INFO)
            # Normal logging (your current behavior minus the -x)
            set -euo pipefail
            exec 1> >(tee -a "$${full_log_path}")
            exec 2> >(tee -a "$${error_log_path}" >&2)
            ;;
        DEBUG)
            # Include debug messages, no bash tracing
            set -euo pipefail
            export DEBUG=1
            exec 1> >(tee -a "$${full_log_path}")
            exec 2> >(tee -a "$${error_log_path}" >&2)
            ;;
        TRACE)
            # Full bash tracing (your current set -euxo pipefail behavior)
            set -euo pipefail
            export DEBUG=1
            # Send trace output to separate file to keep main log clean
            exec 19> "$${trace_log_path}"
            BASH_XTRACEFD=19
            set -x
            exec 1> >(tee -a "$${full_log_path}")
            exec 2> >(tee -a "$${error_log_path}" >&2)
            ;;
        *)
            # Default to INFO for unknown levels
            set -euo pipefail
            exec 1> >(tee -a "$${full_log_path}")
            exec 2> >(tee -a "$${error_log_path}" >&2)
            ;;
    esac
    
    # Export log paths for use by other functions
    export MAIN_LOG_PATH="$${full_log_path}"
    export ERROR_LOG_PATH="$${error_log_path}"
    export DEBUG_LOG_PATH="$${debug_log_path}"
    export TRACE_LOG_PATH="$${trace_log_path}"
}

# Enhanced logging functions with level control
log_trace() {
    [[ "$${LOG_LEVEL:-INFO}" == "TRACE" ]] && echo "[TRACE $(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

log_debug() {
    [[ "$${DEBUG:-0}" == "1" ]] && echo "[DEBUG $(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

log_info() {
    # Only output if log level allows info or higher
    case "$${LOG_LEVEL:-INFO}" in
        ERROR) return 0 ;;  # Skip info in ERROR mode
        *) echo "[INFO $(date '+%Y-%m-%d %H:%M:%S')] $*" ;;
    esac
}

log_warn() {
    echo "[WARN $(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

log_error() {
    echo "[ERROR $(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

log_fatal() {
    echo "[FATAL $(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
    exit 1
}

# Utility function to temporarily disable tracing for clean output sections
quiet_exec() {
    local old_x_state
    old_x_state=$(set +o | grep xtrace)
    set +x
    "$@"
    eval "$old_x_state"
}

# Show current logging configuration (useful for debugging)
log_config_info() {
    echo "=== Logging Configuration ==="
    echo "Log Level: $${LOG_LEVEL:-INFO}"
    echo "Debug Mode: $${DEBUG:-0}"
    echo "Main Log: $${MAIN_LOG_PATH:-<not set>}"
    echo "Error Log: $${ERROR_LOG_PATH:-<not set>}"
    echo "Bash Tracing: $${-/*x*/ENABLED}"
    echo "=========================="
}

# Initialize logging
setup_logging

# Log the configuration
log_info "Logging setup complete. Log file: $${MAIN_LOG_PATH}"
log_debug "Debug logging enabled"
log_trace "Trace logging enabled"


SYSTEM_PREPARED_FILE="/tmp/system_prepared"

# One-time system preparation (run only once across all scripts)
prepare_system_once() {
    if [ "$${SYSTEM_PREPARED}" = "true" ]; then
        log_info "System already prepared, skipping..."
        return 0
    fi
    
    log_info "=== One-time System Preparation ==="
    
    # Wait for system to settle
    log_info "Letting system settle..."
    sleep 30
    
    # Disable unattended-upgrades to prevent conflicts
    log_info "Disabling unattended-upgrades..."
    systemctl stop unattended-upgrades.service || true
    systemctl disable unattended-upgrades.service || true
    systemctl stop apt-daily.timer || true
    systemctl disable apt-daily.timer || true
    systemctl stop apt-daily-upgrade.timer || true
    systemctl disable apt-daily-upgrade.timer || true
    pkill -f unattended-upgrade || true
    sleep 5
    
    # Clear any stale locks
    rm -f /var/lib/apt/lists/lock || true
    rm -f /var/cache/apt/archives/lock || true
    rm -f /var/lib/dpkg/lock-frontend || true
    rm -f /var/lib/dpkg/lock || true
    
    # Initial apt update
    log_info "Initial apt update..."
    retry_apt "apt-get update"
    
    # Mark system as prepared
    SYSTEM_PREPARED=true
    
    # Mark system as prepared (persistent across scripts)
    touch "$${SYSTEM_PREPARED_FILE}"
    export SYSTEM_PREPARED="true"
    
    log_info "System preparation complete"
}

# Robust apt retry function
retry_apt() {
    local cmd="$*"
    local attempts=3
    local delay=15
    
    for i in $(seq 1 $attempts); do
        log_info "Executing: $cmd (attempt $i/$attempts)"
        
        # Quick lock check before each attempt
        if [ $i -gt 1 ]; then
            quick_apt_check || true
        fi
        
        if eval "$cmd"; then
            log_info "Command succeeded: $cmd"
            return 0
        fi
        
        if [ $i -lt $attempts ]; then
            log_warn "Command failed, retrying in $delay seconds..."
            sleep $delay
        fi
    done
    
    log_error "Command failed after $attempts attempts: $cmd"
    return 1
}

# Quick apt availability check
quick_apt_check() {
    local max_wait=60  # 1 minute
    local count=0
    
    while [ $count -lt $max_wait ]; do
        if ! fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 && \
           ! fuser /var/lib/apt/lists/lock >/dev/null 2>&1; then
            return 0
        fi
        
        log_info "Waiting for apt lock... ($count/$max_wait)"
        sleep 5
        count=$((count + 5))
    done
    
    log_warn "Apt lock check timeout, proceeding anyway"
    return 1
}

# Safe package installation wrapper
install_packages() {
    local packages="$*"
    log_info "Installing packages: $packages"
    retry_apt "apt-get install -y $packages"
}

# Safe service management
manage_service() {
    local action="$1"
    local service="$2"
    
    log_info "Service $action: $service"
    systemctl "$action" "$service" || {
        log_warn "Failed to $action $service, continuing..."
        return 1
    }
}

# Cleanup function (can be called at end of final script)
cleanup_system() {
    log_info "=== System Cleanup ==="
    
    # Re-enable unattended-upgrades if desired
    # systemctl enable unattended-upgrades.service || true
    # systemctl start unattended-upgrades.service || true
    
    log_info "Cleanup complete"
}

# Error handling
handle_error() {
    local line_number="$1"
    local error_code="$2"
    log_error "Script failed at line $line_number with exit code $error_code"
    log_error "Last command: $BASH_COMMAND"
    
    # Optional: Add cleanup or debugging info here
    log_error "Current apt processes:"
    ps aux | grep -E "(apt|dpkg|unattended)" | grep -v grep || true
}

# Set up error trap
trap 'handle_error $${LINENO} $?' ERR

log_info "Shared functions loaded successfully"
