#!/bin/bash
# 02-setup-nvme-storage.sh.tftpl
# Worker-specific script for NVMe storage setup and Kubernetes directory optimization

set -euxo pipefail

# =================================================================
# SHARED FUNCTIONS INTEGRATION
# =================================================================
SCRIPT_DIR=${script_dir}

# load shared functions
if [ -f "$${SCRIPT_DIR}/00-shared-functions.sh" ]; then
    source "$${SCRIPT_DIR}/00-shared-functions.sh"
    
    # Verify essential functions are available
    if command -v log_info >/dev/null 2>&1; then
        log_info "Shared functions loaded successfully"
    else
        echo "ERROR: Shared functions loaded but log_info not available"
        exit 1
    fi
else
    echo "ERROR: Cannot find shared functions file: $${SCRIPT_DIR}/00-shared-functions.sh"
    exit 1
fi

setup_logging

if [ -z "$${SYSTEM_PREPARED:-}" ] && [ ! -f "/tmp/.system_prepared" ]; then
    log_info "System not yet prepared, running preparation..."
    prepare_system_once
else
    log_info "System already prepared, skipping preparation"
fi



# =================================================================
# CONFIGURATION VARIABLES (from Terraform)
# =================================================================
readonly TARGET_USER="${k8s_user}"
readonly NVME_MOUNT_POINT="/mnt/nvme_storage"
readonly MIN_NVME_SIZE_BYTES=107374182400  # 100 GiB

log_info "=== NVMe Storage Setup Started ==="
log_info "Target User: $TARGET_USER"
log_info "Mount Point: $NVME_MOUNT_POINT"

# =================================================================
# NVME STORAGE MANAGEMENT
# =================================================================
find_ephemeral_nvme() {
    log_info "Searching for ephemeral NVMe storage..."
    
    # Find root disk to exclude it
    local root_partition=""
    if ! root_partition=$(findmnt -n -o SOURCE /); then
        log_error "Cannot find root partition"
        return 1
    fi
    
    local root_disk=""
    root_disk=$$(lsblk -no pkname "$$root_partition" 2>/dev/null || echo "")
    if [[ -n "$$root_disk" && ! "$$root_disk" =~ ^/ ]]; then
        root_disk="/dev/$$root_disk"
    elif [[ -z "$4root_disk" ]]; then
        root_disk=$(echo "$4root_partition" | sed 's/[0-9]*$//')
    fi
    
    log_info "Root disk identified as: $$root_disk"
    
    # Find suitable NVMe device
    local target_device=""
    while IFS= read -r line; do
        local device type size mountpoint
        read -r devicegg type size mountpoint <<< "$line"
        
        log_info "Evaluating device: $device (type=$type, size=$size, mount=$mountpoint)"
        
        if [[ "$device" =~ ^/dev/nvme && "$type" == "disk" && \
              "$device" != "$root_disk" && "$size" -gt "$MIN_NVME_SIZE_BYTES" ]]; then
            
            if [[ -z "$mountpoint" || "$mountpoint" =~ ^(/mnt|/media/ephemeral) ]]; then
                target_device="$device"
                
                if [[ -n "$mountpoint" && "$mountpoint" != / ]]; then
                    log_info "Unmounting $device from $mountpoint"
                    umount "$device" || log_warn "Failed to unmount $device"
                fi
                break
            fi
        fi
    done < <(lsblk -dpbno NAME,TYPE,SIZE,MOUNTPOINT -e 7)
    
    if [[ -z "$target_device" ]]; then
        log_error "No suitable ephemeral NVMe device found (min size: $MIN_NVME_SIZE_BYTES bytes)"
        log_error "Available devices:"
        lsblk -fp | while IFS= read -r line; do
            log_error "  $line"
        done
        return 1
    fi
    
    log_info "Selected NVMe device: $target_device"
    echo "$target_device"
}

format_and_mount_nvme() {
    local device="$1"
    
    log_info "Formatting $device with XFS filesystem..."
    if mkfs.xfs -f "$device"; then
        log_info "✓ XFS filesystem created successfully"
    else
        log_error "Failed to format $device"
        return 1
    fi
    
    log_info "Creating mount point: $NVME_MOUNT_POINT"
    mkdir -p "$NVME_MOUNT_POINT"
    
    log_info "Mounting $device to $NVME_MOUNT_POINT"
    if mount -t xfs -o discard "$device" "$NVME_MOUNT_POINT"; then
        log_info "✓ NVMe storage mounted successfully"
        df -hT "$NVME_MOUNT_POINT" | while IFS= read -r line; do
            log_info "  $line"
        done
    else
        log_error "Failed to mount $device"
        return 1
    fi
    
    return 0
}

create_directory_structure() {
    log_info "Creating directory structure on NVMe storage..."
    
    # Define directory paths
    local containerd_dir="$NVME_MOUNT_POINT/lib/containerd"
    local kubelet_dir="$NVME_MOUNT_POINT/lib/kubelet"
    local pod_logs_dir="$NVME_MOUNT_POINT/log/pods"
    local local_path_dir="$NVME_MOUNT_POINT/local-path-provisioner"
    local shared_data_dir="$NVME_MOUNT_POINT/shared_data/$TARGET_USER"
    local huggingface_dir="$NVME_MOUNT_POINT/shared_data/$TARGET_USER/huggingface"
    local datasets_dir="$NVME_MOUNT_POINT/shared_data/$TARGET_USER/datasets"
    local llm_models_dir="$NVME_MOUNT_POINT/shared_data/$TARGET_USER/llm_models"
    local user_docker_dir="$NVME_MOUNT_POINT/user_docker_data/$TARGET_USER"
    
    # Create system directories
    log_info "Creating system directories..."
    mkdir -p "$containerd_dir" "$kubelet_dir" "$pod_logs_dir" "$local_path_dir" || {
        log_error "Failed to create system directories"
        return 1
    }
    
    # Create user data directories
    log_info "Creating user data directories..."
    mkdir -p "$shared_data_dir" "$huggingface_dir" "$datasets_dir" "$llm_models_dir" "$user_docker_dir" || {
        log_error "Failed to create user data directories"
        return 1
    }
    
    # Set special permissions for local path provisioner
    chmod 1777 "$local_path_dir"
    log_info "Set sticky bit permissions on local path provisioner directory"
    
    # Set ownership for target user directories
    if id "$TARGET_USER" &>/dev/null; then
        local shared_base=""
        shared_base=$(dirname "$shared_data_dir")
        
        log_info "Setting ownership for $TARGET_USER directories"
        chown -R "$TARGET_USER:$TARGET_USER" "$shared_base"
        chmod -R u=rwX,g=rX,o= "$shared_data_dir"
        
        if [[ -f "/etc/docker/daemon.json" ]]; then
            chown -R "$TARGET_USER:$TARGET_USER" "$user_docker_dir"
            log_info "Set Docker directory ownership for $TARGET_USER"
        fi
        
        log_info "✓ User directory ownership configured"
    else
        log_warn "User $TARGET_USER not found, skipping ownership changes"
    fi
    
    # Export paths for use in symlink creation
    export NVME_CONTAINERD_DIR="$containerd_dir"
    export NVME_KUBELET_DIR="$kubelet_dir"
    export NVME_POD_LOGS_DIR="$pod_logs_dir"
    
    log_info "✓ Directory structure created successfully"
    return 0
}

stop_kubernetes_services() {
    log_info "Stopping services for symlink setup..."
    
    # Stop Docker if present and running
    if systemctl list-units --full -all | grep -q 'docker.service'; then
        if systemctl is-active --quiet docker; then
            manage_service "stop" "docker.socket" || log_warn "Failed to stop docker.socket"
            manage_service "stop" "docker.service" || log_warn "Failed to stop docker.service"
        fi
    fi
    
    # Stop Kubernetes services
    manage_service "stop" "kubelet" || log_info "kubelet not running"
    
    if manage_service "stop" "containerd"; then
        log_info "✓ containerd stopped"
    else
        log_error "Failed to stop containerd"
        return 1
    fi
    
    sleep 3  # Allow services to release file locks
    return 0
}

start_kubernetes_services() {
    log_info "Starting services after symlink setup..."
    
    if manage_service "start" "containerd"; then
        log_info "✓ containerd started"
    else
        log_error "Failed to start containerd"
        return 1
    fi
    
    # Start Docker if configured
    if systemctl list-units --full -all | grep -q 'docker.service' && [[ -f "/etc/docker/daemon.json" ]]; then
        manage_service "start" "docker.socket" || log_warn "Failed to start docker.socket"
        manage_service "start" "docker.service" || log_warn "Failed to start docker.service"
    fi
    
    return 0
}

create_kubernetes_symlinks() {
    log_info "Creating Kubernetes directory symlinks..."
    
    local success=true
    
    # Create symlinks with error handling
    create_symlink "$NVME_CONTAINERD_DIR" "/var/lib/containerd" || success=false
    create_symlink "$NVME_KUBELET_DIR" "/var/lib/kubelet" || success=false
    create_symlink "$NVME_POD_LOGS_DIR" "/var/log/pods" || success=false
    
    if $success;
     then
        log_info "✓ All Kubernetes symlinks created successfully"
        return 0
    else
        log_error "Failed to create one or more Kubernetes symlinks"
        return 1
    fi
}

create_symlink() {
    local target_path="$1"
    local link_path="$2"
    
    log_info "Creating symlink: $link_path -> $target_path"
    
    # Ensure parent directory exists
    mkdir -p "$(dirname "$link_path")"
    
    # Handle existing symlink
    if [[ -L "$link_path" ]]; then
        if [[ "$(readlink -f "$link_path")" == "$target_path" ]]; then
            log_info "Symlink already correct: $link_path"
            return 0
        else
            log_info "Removing incorrect symlink: $link_path"
            rm -f "$link_path"
        fi
    elif [[ -e "$link_path" ]]; then
        local backup_path="$${link_path}.backup.$$(date +%s)"
        log_info "Backing up existing path: $link_path -> $backup_path"
        mv "$link_path" "$backup_path" || log_warn "Failed to backup $link_path"
    fi
    
    # Create the symlink
    if ln -sf "$target_path" "$link_path"; then
        chown -h root:root "$link_path"
        log_info "✓ Symlink created: $link_path"
        return 0
    else
        log_error "Failed to create symlink: $link_path"
        return 1
    fi
}

setup_ssh_for_user() {
    log_info "Setting up SSH for target user..."
    
    if ! id "$TARGET_USER" &>/dev/null; then
        log_warn "User $TARGET_USER not found, skipping SSH setup"
        return 0
    fi
    
    local default_user="ubuntu"
    local default_keys="/home/$default_user/.ssh/authorized_keys"
    local user_ssh_dir="/home/$TARGET_USER/.ssh"
    local user_keys="$user_ssh_dir/authorized_keys"
    
    if [[ ! -f "$default_keys" ]]; then
        log_warn "Default user authorized_keys not found: $default_keys"
        return 0
    fi
    
    log_info "Setting up SSH keys for $TARGET_USER"
    mkdir -p "$user_ssh_dir"
    
    if cp "$default_keys" "$user_keys"; then
        chown -R "$TARGET_USER:$TARGET_USER" "$user_ssh_dir"
        chmod 700 "$user_ssh_dir"
        chmod 600 "$user_keys"
        log_info "✓ SSH keys configured for $TARGET_USER"
    else
        log_error "Failed to copy SSH keys for $TARGET_USER"
        return 1
    fi
    
    return 0
}

# =================================================================
# MAIN EXECUTION
# =================================================================
main() {
    log_info "Starting NVMe storage setup..."
    
    # Find and setup NVMe storage
    local nvme_device=""
    if ! nvme_device=$(find_ephemeral_nvme); then
        log_error "Failed to find suitable NVMe device"
        return 1
    fi
    
    if ! format_and_mount_nvme "$nvme_device"; then
        log_error "Failed to format and mount NVMe storage"
        return 1
    fi
    
    if ! create_directory_structure; then
        log_error "Failed to create directory structure"
        return 1
    fi
    
    # Service and symlink management
    if ! stop_kubernetes_services; then
        log_error "Failed to stop Kubernetes services"
        return 1
    fi
    
    if ! create_kubernetes_symlinks; then
        log_error "Failed to create Kubernetes symlinks"
        return 1
    fi
    
    if ! start_kubernetes_services; then
        log_error "Failed to start Kubernetes services"
        return 1
    fi
    
    # User setup
    setup_ssh_for_user || log_warn "SSH setup for user failed"
    
    log_info "=== NVMe Storage Setup Completed Successfully ==="
    log_info "✓ NVMe Device: $nvme_device"
    log_info "✓ Mount Point: $NVME_MOUNT_POINT"
    log_info "✓ Kubernetes directories symlinked to NVMe storage"
    log_info "✓ Services restarted: containerd"
    log_info "✓ Target user configured: $TARGET_USER"
    
    return 0
}

# Execute main function
main "$@"
